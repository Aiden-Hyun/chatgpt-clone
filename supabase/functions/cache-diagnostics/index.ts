import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { CacheManager } from "../react-search/cache.ts";
import { config } from "../shared/config.ts";

serve(async (req) => {
  const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") || "*";
  const DEBUG = Deno.env.get("DEBUG_LOGS") === "true";

  console.log(`[CACHE-DIAGNOSTICS] Function called at ${new Date().toISOString()}`);
  console.log(`[CACHE-DIAGNOSTICS] Request method: ${req.method}`);

  if (req.method === "OPTIONS") {
    return new Response("ok", {
      headers: {
        "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
        "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      },
    });
  }

  try {
    // --- Authentication ---
    const authHeader = req.headers.get("authorization");
    if (!authHeader) throw new Error("Missing authorization header");
    
    const supabaseClient = createClient(config.secrets.supabase.url(), config.secrets.supabase.anonKey(), {
      global: { headers: { Authorization: authHeader } },
    });
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser();
    if (authError || !user) throw new Error("Invalid JWT");

    // Create a service role client for cache operations
    const supabaseServiceClient = createClient(
      config.secrets.supabase.url(),
      config.secrets.supabase.serviceRoleKey()
    );
    
    // Initialize CacheManager with debug enabled
    const cacheManager = new CacheManager(supabaseServiceClient, { debug: true });

    // Get cache diagnostics
    const diagnostics = await cacheManager.getDiagnostics();

    // Get cache table schema
    const { data: tableInfo, error: tableError } = await supabaseServiceClient
      .from('agent_cache')
      .select('*')
      .limit(0);

    // Check if we need to create the table
    let tableExists = true;
    let tableCreationResult = null;

    if (tableError && tableError.code === '42P01') { // Table doesn't exist
      tableExists = false;
      
      // Try to create the table
      try {
        const createTableSQL = `
          CREATE TABLE IF NOT EXISTS public.agent_cache (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            cache_type TEXT NOT NULL,
            key TEXT NOT NULL,
            value JSONB NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            expires_at TIMESTAMPTZ NOT NULL,
            metadata JSONB
          );
          CREATE UNIQUE INDEX IF NOT EXISTS agent_cache_type_key_idx ON public.agent_cache (cache_type, key);
          CREATE INDEX IF NOT EXISTS agent_cache_expires_at_idx ON public.agent_cache (expires_at);
          GRANT ALL ON TABLE public.agent_cache TO service_role;
          GRANT USAGE, SELECT ON SEQUENCE agent_cache_id_seq TO service_role;
          ALTER TABLE public.agent_cache ENABLE ROW LEVEL SECURITY;
          CREATE POLICY "Service role can do anything on agent_cache" ON public.agent_cache FOR ALL TO service_role USING (true);
        `;
        
        const { error } = await supabaseServiceClient.rpc('pgcli', { command: createTableSQL });
        tableCreationResult = error ? { error: error.message } : { success: true };
      } catch (error) {
        tableCreationResult = { error: String(error) };
      }
    }

    // Get sample entries
    let sampleEntries = [];
    if (tableExists || tableCreationResult?.success) {
      const { data: samples, error: samplesError } = await supabaseServiceClient
        .from('agent_cache')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(5);
        
      if (!samplesError && samples) {
        sampleEntries = samples;
      }
    }

    // Clean up expired entries
    const cleanupCount = await cacheManager.cleanupExpired();

    // Create a test entry
    const testKey = `test-${Date.now()}`;
    const testValue = { timestamp: Date.now(), message: "Cache test entry" };
    const testResult = await cacheManager.set('search', testKey, testValue, 60);

    // Try to retrieve the test entry
    const retrievedTest = await cacheManager.get('search', testKey);

    // Prepare response
    const result = {
      diagnostics,
      tableStatus: {
        exists: tableExists,
        creationResult: tableCreationResult
      },
      cleanup: {
        expiredEntriesRemoved: cleanupCount
      },
      test: {
        writeSuccess: testResult,
        readSuccess: !!retrievedTest,
        valueMatch: JSON.stringify(testValue) === JSON.stringify(retrievedTest)
      },
      sampleEntries
    };

    return new Response(JSON.stringify(result, null, 2), {
      headers: { 
        "Content-Type": "application/json", 
        "Access-Control-Allow-Origin": ALLOWED_ORIGIN 
      },
    });

  } catch (error) {
    console.error('[CACHE-DIAGNOSTICS] Error processing request', { 
      message: typeof error === "object" && error !== null && "message" in error ? (error as any).message : String(error),
      stack: typeof error === "object" && error !== null && "stack" in error ? (error as any).stack : undefined
    });
    
    return new Response(JSON.stringify({ 
      error: typeof error === "object" && error !== null && "message" in error ? (error as any).message : String(error),
      stack: typeof error === "object" && error !== null && "stack" in error ? (error as any).stack : undefined
    }), {
      status: 400,
      headers: { 
        "Content-Type": "application/json", 
        "Access-Control-Allow-Origin": ALLOWED_ORIGIN 
      },
    });
  }
});

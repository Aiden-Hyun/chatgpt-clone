-- Create a single consolidated cache table with a type field
CREATE TABLE IF NOT EXISTS public.agent_cache (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cache_type TEXT NOT NULL, -- 'search', 'url', 'answer'
  key TEXT NOT NULL,
  value JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  metadata JSONB -- Optional metadata for debugging
);

-- Create a unique constraint on cache_type + key
CREATE UNIQUE INDEX IF NOT EXISTS agent_cache_type_key_idx ON public.agent_cache (cache_type, key);

-- Create an index for expiration cleanup
CREATE INDEX IF NOT EXISTS agent_cache_expires_at_idx ON public.agent_cache (expires_at);

-- Grant permissions to service_role
GRANT ALL ON TABLE public.agent_cache TO service_role;
GRANT USAGE, SELECT ON SEQUENCE agent_cache_id_seq TO service_role;

-- Enable Row Level Security
ALTER TABLE public.agent_cache ENABLE ROW LEVEL SECURITY;

-- Create a policy that allows service_role to do anything
CREATE POLICY "Service role can do anything on agent_cache" 
ON public.agent_cache 
FOR ALL 
TO service_role
USING (true);

-- Create a policy that allows authenticated users to read
CREATE POLICY "Authenticated users can read agent_cache" 
ON public.agent_cache 
FOR SELECT 
TO authenticated
USING (true);

-- Create a function to clean up expired cache entries
CREATE OR REPLACE FUNCTION cleanup_expired_cache()
RETURNS void AS $$
BEGIN
  DELETE FROM public.agent_cache WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- Create a cron job to clean up expired cache entries daily
-- Requires pg_cron extension
-- COMMENT OUT if pg_cron is not available
-- SELECT cron.schedule('0 3 * * *', 'SELECT cleanup_expired_cache()');
